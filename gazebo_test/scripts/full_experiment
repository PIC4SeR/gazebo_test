#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import argparse
import libtmux
import os
import time
import shtab
import argcomplete
from pathlib import Path
import pandas as pd


def print_summary(log_path: Path):
    """
    Print the summary of the gazebo test.
    """
    # Check if the log file exists
    if not os.path.exists(log_path):
        print(f"Log file {log_path} does not exist.")
        return

    # Read the csv file and print the summary in a table format
    df = pd.read_csv(log_path)
    # Print the summary of the gazebo test
    print("Summary of the gazebo test:")
    print("--------------------------------------------------")
    print(f"Number of total experiments: {len(df)}")
    print("--------------------------------------------------")
    # Print the columns of the dataframe
    print("--------------------------------------------------")
    print(df)
    print("--------------------------------------------------")


def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Script to control bag recording and headless mode."
    )
    parser.add_argument(
        "--bag-record", action="store_true", help="Enable bag recording"
    )
    parser.add_argument("--headless", action="store_true", help="Run in headless mode")

    parser.add_argument(
        "--wait-after-finish",
        action="store_true",
        help="Wait for the user to press Ctrl+C after the test is finished",
    )
    # Hook argcomplete
    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    # Create a new tmux server
    server = libtmux.Server()
    # Check if the session already exists
    session_name = "gazebo_test"
    try:
        if session_name in server.sessions:
            print(f"Session '{session_name}' already exists. Exiting.")
            return
    except libtmux.exc.LibTmuxException:
        print("Tmux server not running. Starting a new server.")

    # Create a new tmux session
    with libtmux.Server() as server:
        with server.new_session(session_name=session_name) as session:
            print(f"Created new session: {session_name}")

            # Create a window for gazebo simulation
            # session.new_window(attach=False, window_name="Gazebo")

            window = session.active_window
            window.rename_window("Gazebo")
            print("Created new window: Gazebo")
            # Start the Gazebo simulation
            # pane = window.split(attach=True)
            pane = window.panes[0]
            pane.select()
            pane.send_keys("ros2 launch gazebo_sim simulation.launch.py")
            print("Started Gazebo simulation")

            session.new_window(attach=True, window_name="Navigation")
            window = session.active_window
            window.rename_window("Navigation")
            print("Created new window: Navigation")
            # Start the navigation stack
            pane = window.panes[0]
            pane.select()
            pane.send_keys("ros2 launch gazebo_test bringup.launch.py")
            print("Started navigation stack")

            # Create a new pane for RViz
            session.new_window(attach=True, window_name="RViz")
            window = session.active_window
            window.rename_window("RViz")
            print("Created new window: RViz")
            # Start RViz
            pane = window.panes[0]
            pane.select()
            pane.send_keys("ros2 launch gazebo_test rviz.launch.py")
            print("Started RViz")

            session.new_window(attach=True)
            window = session.active_window
            window.rename_window("gazebo test")
            print("Created new window: gazebo test")
            # Start the gazebo test
            pane = window.panes[0]
            pane.select()
            pane.send_keys(
                f"ros2 run gazebo_test experiment_manager --ros-args -p use_sim_time:=True -p use_recorder:={args.bag_record}; tmux wait-for -S process_finished"
            )
            print("Started gazebo test")

            # run until the user presses Ctrl+C or until the gazebo test is finished

            try:
                server.cmd("wait-for", "process_finished")
                print("Gazebo test finished")
                # retrieve the log of the gazebo test
                # open a new terminal and run the following command (not in tmux):
                # tmux attach-session -t gazebo_test:0
                current_panel = "".join(pane.capture_pane())
                # get the path of the log file
                log_path = current_panel.split("saved to ")[-1].split("[")[0]

                # remove leading and trailing spaces
                log_path = log_path.strip()

                print_summary(log_path)
                # print the summary of the gazebo test
                # retrieve the log of the gazebo test

                # wait until the keyboard interrupt
                if args.wait_after_finish:
                    print("Press Ctrl+C to exit...")
                    while True:
                        time.sleep(1)
            except KeyboardInterrupt:
                print("Exiting...")


if __name__ == "__main__":
    main()
